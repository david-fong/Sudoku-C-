
# Things To Do

- Run some more repeated tests and get some performance data.
  - Report findings in the main readme file.
- Change occmask_t fields to use std::bitset.
  - Can try adding a short-circuit step to traversal: if setting an occ bit makes all its bits set for a group and that group has a tile that is clear, then backtrack. This would only be efficient if we maintain a bitset for each group of each type saying which tiles are clear... We should try this as an experiment.
- Make non-prompt output text print to cout and to outStream (if outStream is not same as cout).
  - This includes the preamble of parameters that were parsed.
  - Investigate if it is simplest to do this with a macro :P.
- Set a compilation flag for whether to track number of operations on a Tile per run.
  - This would help me get an overview of what traversals look like and what patterns there are.
- Make the Sudoku class take type parameters for the field widths, and then the main function use a switch statement to instantiate one.

## OK cool

An old TODO: Perform benchmarks comparing performance (time and number of operations) with and without seeds.

For 16x16, running 1024 trials, using no seeds was much faster in terms of time, had less than half the number of aborted trials, and took about six times fewer operations. I am shocked. This is amazing.

### Order 5

- 1580684771 is a seed where for order-5 generations which succeed quickly for runs #1, #5, #9, #15.
- 1580685437 #2, #7, #18, #19, #35,
- 1580685741 #1, #14,
- 1580858187 #0, #3, #4, #6,

## "Failed" Experiment

This didn't end up working.

- Try making traversal order not grid-row-major and see if it improves performance:
  - Hypothesis: Tiles with fewer candidates are like the solution space's dominant bottlenecks. If we were to leave them to the end, we may spend many long advances creating almost-complete solutions that cannot be complete because they violate the bottlenecks (and possibly often in similar ways). If we start with them first, we may be less likely to encounter that problem.
  - Need to give the Tile class an instance field for their og index since that's how we index their group-occupancy vectors and rowBias vectors.
  - Invariant: At the beginning of solution generation, we can filter for all un-seeded tiles and sort them in ascending order of number of remaining candidates. I haven't thought it out 100% yet, but I believe we cannot update this traversal order intermittently (even if we only sort those past the current traversal index) because it could make us miss some outputs or put us in an infinite loop of testing a cycle of outputs. I feel like that's a bit of a bummer, but at this point there are many things I'm not sure of yet, so I'll try to hold that feeling back.

## Bookmarks

```text
https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html
```
